(def usage
  ``
  Usage: pdoc -h|--help
         pdoc [option] [peg-special]

  View peg information.

    -h, --help                show this output

    -d, --doc <peg-special>   show doc
    -x, --eg <peg-special>    show examples

    --bash-completion         output bash-completion bits
    --raw-all                 show all names to help completion

  With a peg-special, but no options, show docs and examples.
  If any of "integer", "string", or "struct" are specified as the
  "peg-special", show docs and examples about using those as PEG
  constructs.

  With the `-d` or `--doc` option and a peg-special (or one of the
  exceptions mentioned above), show associated docs.

  With the `-x` or `--eg` option and a peg-special (or one of the
  exceptions mentioned above), show associated examples.

  With no arguments, lists all peg specials.

  Be careful to quote shortnames (e.g. *, ->, >, <-) appropriately
  so the shell doesn't process them in an undesired fashion.
  ``)

(defn dump-doc
  [file-path]
  (def content
    (slurp file-path))
  (def lines
    (string/split "\n" content))
  (when (empty? (array/peek lines))
    (array/pop lines))
  (each line lines
    (->> line
         (peg/match ~(sequence "# "
                               (capture (to -1))))
         first
         print)))

# assumes example file has certain structure
(defn massage-lines-for-examples
  [lines]
  (def n-lines (length lines))
  (def m-lines @[])
  (var i 0)
  # skip first line if import
  (when (peg/match ~(sequence "(import")
                   (first lines))
    (++ i))
  # get "inside" comment form
  (while (< i n-lines)
    (def cur-line (get lines i))
    # whether loop ends or not, index increases
    (++ i)
    # stop at first (comment ...) form
    (when (peg/match ~(sequence "(comment")
                     cur-line)
      (break)))
  # save lines until (comment ...) ends
  (while (< i n-lines)
    (def cur-line (get lines i))
    # supposedly where the "(comment ...)" form ends -- hacky
    (if (peg/match ~(sequence (any (set " \t\f\v"))
                              ")")
                   cur-line)
      (break)
      (if (string/has-prefix? "  " cur-line)
        (array/push m-lines (string/slice cur-line 2))
        (array/push m-lines cur-line)))
    (++ i))
  #
  m-lines)

(defn dump-special-examples
  [file-path]
  (def content
    (slurp file-path))
  (def lines
    (string/split "\n" content))
  (def examples-lines
    (massage-lines-for-examples lines))
  (each line examples-lines
    (print line)))

# assumes example file has certain structure
(defn massage-lines-for-doc
  [lines]
  (def m-lines @[])
  (var i 0)
  # skip first line if import
  (when (peg/match ~(sequence "(import")
                   (first lines))
    (++ i))
  (while (< i (length lines))
    (def cur-line (get lines i))
    # stop at first (comment ...) form
    (if (peg/match ~(sequence "(comment")
                     cur-line)
      (break)
      (if (string/has-prefix? "# " cur-line)
        (array/push m-lines (string/slice cur-line 2))
        (array/push m-lines cur-line)))
    (++ i))
  #
  m-lines)

(defn dump-special-doc
  [file-path]
  (def content
    (slurp file-path))
  (def lines
    (string/split "\n" content))
  (def doc-lines
    (massage-lines-for-doc lines))
  (each line doc-lines
    (print line)))

(def alias-table
  {"+" "choice"
   "*" "sequence"
   "opt" "between"
   "?" "between"
   "!" "not"
   ">" "look"
   "<-" "capture"
   "quote" "capture"
   "/" "replace"
   "$" "position"
   "%" "accumulate"
   "->" "backref"
   #
   "integer" "0.integer"
   "string" "0.string"
   "struct" "0.struct"})

(defn parse-argv
  [argv]
  (def opts @{})
  (def rest @[])
  (def argc (length argv))
  #
  (when (> argc 1)
    (var i 1)
    (while (< i argc)
      (def arg (get argv i))
      (cond
        (get {"--bash-completion" true} arg)
        (put opts :bash-completion true)
        #
        (get {"--raw-all" true} arg)
        (put opts :raw-all true)
        #
        (get {"--doc" true
              "-d" true}
             arg)
        (put opts :doc true)
        #
        (get {"--eg" true
              "-x" true}
             arg)
        (put opts :eg true)
        #
        (get {"--help" true
              "-h" true}
             arg)
        (put opts :help true)
        #
        (array/push rest arg))
      (++ i)))
  #
  [opts rest])

(defn print-all-names
  [dir-path]
  (def file-names (os/dir dir-path))
  (def names
    (->> file-names
         # drop .janet extension
         (map |(string/slice $ 0
                             (last (string/find-all "." $))))
         # only keep things that have names
         (filter |(not (string/has-prefix? "0." $)))))
  # add things with no names
  (array/push names "integer")
  (array/push names "string")
  (array/push names "struct")
  (each alias (keys alias-table)
    (let [name (get alias-table alias)]
      (unless (string/has-prefix? "0." name)
        (when (index-of name names)
          (array/push names alias)))))
  # print all names
  (each name (sort names)
    (cond
      (= name "*")
      # XXX: not sure if this quoting will work on windows...
      (print "\"*\"")
      #
      (= name "->")
      (print "\"->\"")
      #
      (= name ">")
      (print "\">\"")
      #
      (= name "<-")
      (print "\"<-\"")
      #
      (print name))))

(def bash-completion
  ``
  _pdoc_specials() {
      COMPREPLY=( $(compgen -W "$(pdoc --raw-all)" -- ${COMP_WORDS[COMP_CWORD]}) );
  }
  complete -F _pdoc_specials pdoc
  ``)

(defn main
  [& argv]
  (def [opts rest]
    (parse-argv argv))

  (when (opts :help)
    (print usage)
    (os/exit 0))

  (when (or (opts :doc) (opts :eg))
    (when (empty? rest)
      (eprint "Need one non-option argument.")
      (os/exit 1)))

  (when (opts :bash-completion)
    (print bash-completion)
    (os/exit 0))

  # show all special names including aliases (and string, integer, struct)
  (when (opts :raw-all)
    (if-let [[file-path _]
             (module/find "pegdoc/examples/0.all-the-names")]
      (let [dir-path
            (string/slice file-path 0
                          (last (string/find-all "/" file-path)))]
        (print-all-names dir-path)
        (os/exit 0))
      (do
        (eprint "Hmm, something is wrong, failed to find names.")
        (os/exit 1))))

  (def peg-special
    (let [cand (first rest)]
      (if-let [alias (get alias-table cand)]
        alias
        cand)))

  # show info about all specials
  (unless peg-special
    (if-let [[file-path _]
             (module/find "pegdoc/examples/0.all-the-names")]
      (do
        (dump-doc file-path)
        (os/exit 0))
      (do
        (eprint "Hmm, something is wrong, failed to find all the names.")
        (os/exit 1))))

  # show docs and/or examples for a peg-special
  (let [[file-path _]
        (module/find (string "pegdoc/examples/" peg-special))]

    (unless file-path
      (eprintf "Did not find doc for `%s`" peg-special)
      (os/exit 1))

    (unless (os/stat file-path)
      (eprintf "Hmm, something is wrong, failed to find file: %s"
               file-path)
      (os/exit 1))

    (when (or (and (opts :doc) (opts :eg))
              (and (nil? (opts :doc)) (nil? (opts :eg))))
      (dump-special-doc file-path)
      (print (string/repeat "#" 68))
      (dump-special-examples file-path)
      (os/exit 0))

    (when (opts :doc)
      (dump-special-doc file-path))

    (when (opts :eg)
      (dump-special-examples file-path))))

